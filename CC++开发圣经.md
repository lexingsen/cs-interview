[TOC]

# C/C++开发面试

### 1、减少临时对象的生成

- 形式参数使用引用传递，不要使用值传递，减少一次临时对象的生成
- 函数返回时，返回临时对象，不要先定义对象，然后再返回。直接提前计算好构造改对象的构造函数所需要的参数，直接返回临时对象。
- 当接受函数返回值为对象的函数的返回值时，以初始化的方式接受，不要以赋值的方式接受。
- 当以临时对象拷贝构造一个新对象时，编译器不会产生这个临时对象，直接以构造临时对象的方式直接构造新对象，减少一次临时对象的构造和析构。

### 2、初始化列表

- 初始化列表在构造函数执行前执行，有类成员对象的类一定要使用初始化列表初始化类成员对象。
- 类中的const常量和引用变量必须放在初始化列表中，因为他们必须进行初始化。
- 初始化的顺序是按照定义的顺序。
- 分清楚初始化和赋值的区别。构造函数中进行的是赋值，初始化列表中进行的是初始化。

### 3、迭代器失效

### 4、拷贝构造函数和赋值运算符重载函数

- 拷贝构造函数的形式参数为什么是常引用？
  - 传递引用是防止无限递归调用拷贝构造函数
  - const是为了保证数据安全，因为传递的是引用，不够安全
- 赋值运算符重载函数为什么返回引用？
  - 防止使用临时对象拷贝构造
  - 可以进行连续赋值
  - 避免多次临时对象的构造和析构

### 5、浅拷贝和自赋值

### 6、全局对象 栈对象 堆对象  static对象 const对象 构造和析构的顺序

### 7、内联函数、普通函数、宏定义

### 8、C/C++的函数调用约定

### 9、强符号和弱符号

### 10、C调用C++和C++调用C

### 11、函数默认参数

### 12、智能指针

### 13、C++11 move实现

### 14、编译器在什么情况下无法产生类的四个默认函数

- 当成员变量有const**常量、引用**的时候，不能产生默认的构造函数。
- 因为这两个是C++唯一必须赋初始值和不能被更改的成员变量，不能产生默认的赋值函数。
- 编译器默认赋值函数会对引用本身的指针大小的内存进行值拷贝，自己写的赋值函数会自动解引用所以是对引用对象进行赋值操作。
- const常量的话，因为不允许修改，所以编译器也不能产生为含有const常量的类默认的赋值函数。

### 15、多态的实现

### 16、重载、覆盖、重写

### 18、菱形继承的问题及解决方案

### 19、vector的扩容机制

### 20、引用和指针的区别

### 21、new和malloc，delete和free的区别

### 22、构造函数中调用普通函数和虚函数

### 23、右值引用和左值引用

### 24、完美转发和移动语义

### 25、lambda表达式的实现

### 26、函数模板和类模板

### 27、构造函数里 new 自己

### 28、struct 的对齐

### 29、C++ 的默认函数有哪些，什么时候生成这些默认函数

### 30、数组的内存模型

### 31、C++ 新特性中的哪里用到了协程

### 32、虚函数，虚指针、虚表

### 33、虚析构？作用？

### 34、内存泄漏诊断？

### 35、空间配置器；一级空间配置器；二级空间配置器

### 36、map介绍一下，为什么使用红黑树；find 如何实现

### 37、大端小端；如何鉴别大端小端

### 38、指针与数组的区别；指针++与数组++的结果

### 39、sizeof (指针)、sizeof (数组)为多少？

### 40、static 关键字介绍

### 41、explicit extern 作用解释

### 42、const 关键字解释；const 能否修饰全局函数？

### 43、volatile关键字的作用

### 44、placement new？

### 45、类的前置声明？

- 前置声明只能作为指针或引用，不能定义类的对象
- 好处是不引入过多的头文件，不暴露过多的信息
- c++这种语言编译的时候需要知道对象的大小，也就是 sizeof你得出来准确的值，那么要求你类中的变量类型都是确定的

### 46、C++ Impl手法

- 使用引用/指针，因为引用/指针的大小是固定的 指针大小
- https://www.cnblogs.com/chaohacker/p/14907757.html
- 降低耦合
- 信息隐藏
- 降低编译依赖，提高编译速度
- 接口与实现分离
- Pimpl解除了接口与实现之间的耦合关系，从而降低文件间的编译依赖关系，Pimpl也因此常被称为“编译期防火墙“ 

### 47、C++的四种new

48、

49、

50